---
title: "Dilution series analysis"
author: "Vincent Caruso"
date: "August 25, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Set up the environment.
```{r setup}

library(dada2)
library(stringr)
library(Biostrings)
library(tidyverse)
library(ShortRead)

options(tibble.print_min = 10, tibble.print_max = 40)
# options(tibble.width = Inf)

data_path <- "~/thesis/data/dilution"
result_path <- "~/thesis/results/dilution"
ref_path <- "~/thesis/references/zymo_SSU"
analysis_path <- "~/thesis/analysis/dilution"
script_path <- "~/thesis/noisy-microbes/scripts"

source(file.path(script_path, "seq_table_processing.R"))

if (!file_test("-d", analysis_path)) dir.create(analysis_path)

```

##Load and format OTU/SV tables from each method

Load and inspect the tables from each clustering method. Modify tables as necessary so that they all have the following format:

1. Rows are OTUs or SVs
2. The first column is the OTU/SV identifier, and the remaining columns are samples' abundances
3. There are no comment lines (just a header with column names)

After modifying the format of each table, write it back to a tab-separated '.txt' file.
```{r load UCLUST}

# load UCLUST table
uclust_otu_file <- file.path(result_path, "uclust/otu_table.txt")
uclust_seqs_file <- file.path(result_path, "uclust/rep_set/pooled_nochim_rep_set.fasta")
uclust_table <- load_uclust(uclust_otu_file, uclust_seqs_file, min_abund = 10)
# uclust_table <- as.tibble(read.table(file = file.path(result_path, "uclust/otu_table.txt"), header = TRUE, sep = "\t", 
#                                      skip = 1, comment.char = ""))
# colnames(uclust_table)[1] <- "id"
# uclust_table$id <- str_replace(uclust_table$id, "denovo", "denovo_")  # make ids more readable
# sample_names <- colnames(uclust_table)[-1]  # get the sample names, which will be used for all tables for consistency
# sample_names <- sample_names[order(sample_names)]
# uclust_table <- uclust_table %>% select(id, sample_names)
# uclust_table <- uclust_table[apply(uclust_table[, sample_names], 1, max) > 1, ]  # remove singletons
uclust_table
write_tsv(uclust_table %>% select(-sequence), file.path(result_path, "uclust/uclust_table.txt"))

sample_names <- colnames(uclust_table)[c(-1, -length(colnames(uclust_table)))]

# load UCLUST representative sequences
# uclust_seqs <- readDNAStringSet(file.path(result_path, "uclust/rep_set/pooled_nochim_rep_set.fasta"))
# uclust_seqs <- as.character(uclust_seqs)
# names(uclust_seqs) <- sapply(str_split(names(uclust_seqs), " "), `[`, 1)  # remove annotation from names
# names(uclust_seqs) <- str_replace(names(uclust_seqs), "denovo", "denovo_")  # modify names to match table ids
# uclust_table$sequence <- uclust_seqs[uclust_table$id]  # add sequences to table
# uclust_seqs <- uclust_seqs[uclust_table$id]

```


```{r load UPARSE}

# load UPARSE table
uparse_otu_file <- file.path(result_path, "uparse/otu_table.txt")
uparse_seqs_file <- file.path(result_path, "uparse/otus.fa")
uparse_table <- load_uparse(uparse_otu_file, uparse_seqs_file, sample_names = sample_names, min_abund = 10)
# uparse_table <- as.tibble(read.table(file = file.path(result_path, "uparse/otu_table.txt"), header = TRUE, sep = "\t",
#                                      comment.char = ""))
# colnames(uparse_table)[1] <- "id"
# uparse_table$id <- str_replace(uparse_table$id, "OTU", "OTU_")
# colnames(uparse_table)[-1] <- sample_names  # make sample names match UCLUST table
# uparse_table <- uparse_table[apply(uparse_table[, sample_names], 1, max) > 1, ]  # remove singletons
uparse_table
write_tsv(uparse_table %>% select(-sequence), file.path(result_path, "uparse/uparse_table.txt"))

# load UPARSE representative sequences
# uparse_seqs <- readDNAStringSet(file.path(result_path, "uparse/otus.fa"))
# uparse_seqs <- as.character(uparse_seqs)
# names(uparse_seqs) <- str_replace(names(uparse_seqs), "OTU", "OTU_")
# uparse_table$sequence <- uparse_seqs[uparse_table$id]  # add sequences to table
# uparse_seqs <- uparse_seqs[uparse_table$id]

```


```{r load UNOISE}

# load UNOISE table
unoise_otu_file <- file.path(result_path, "unoise/zotu_table.txt")
unoise_seqs_file <- file.path(result_path, "unoise/zotus.fa")
unoise_table <- load_unoise(unoise_otu_file, unoise_seqs_file, sample_names = sample_names, min_abund = 10)

# unoise_table <- as.tibble(read.table(file = file.path(result_path, "unoise/zotu_table.txt"), header = TRUE, sep = "\t", 
#                                      comment.char = ""))
# colnames(unoise_table)[1] <- "id"
# unoise_table$id <- str_replace(unoise_table$id, "OTU", "ZOTU_")
# colnames(unoise_table)[-1] <- sample_names
# unoise_table <- unoise_table[apply(unoise_table[, sample_names], 1, max) > 1, ]  # remove singletons
unoise_table
write_tsv(unoise_table %>% select(-sequence), file.path(result_path, "unoise/unoise_table.txt"))

# load UNOISE sequences
# unoise_seqs <- readDNAStringSet(file.path(result_path, "unoise/zotus.fa"))
# unoise_seqs <- as.character(unoise_seqs)
# names(unoise_seqs) <- sapply(names(unoise_seqs), FUN = str_replace, "OTU", "ZOTU_")
# unoise_table$sequence <- unoise_seqs[unoise_table$id]  # add sequences to table
# unoise_seqs <- unoise_seqs[unoise_table$id]

```


```{r load MED}

# load MED table
med_otu_file <- file.path(result_path, "med/MATRIX-COUNT.txt")
med_seqs_file <- file.path(result_path, "med/NODE-REPRESENTATIVES.fasta")
med_chimera_file <- file.path(result_path, "med/uchime/NODE-chimeras.fasta")
med_table <- load_med(med_otu_file, med_seqs_file, med_chimera_file)

# med_table <- read.table(file = file.path(result_path, "med/MATRIX-COUNT.txt"), header = TRUE, sep = "\t")
# row.names(med_table) <- med_table[, 1]
# med_table <- med_table[, -1]  # remove sample name column
# med_table <- data.frame(t(med_table))   # samples as columns
# med_table <- as.tibble(rownames_to_column(med_table, var = "id"))
# med_table$id <- str_replace(med_table$id, "X", "Node_")
med_table

# load MED sequences
# med_seqs <- readDNAStringSet(file.path(result_path, "med/NODE-REPRESENTATIVES.fasta"))
# med_seqs <- as.character(med_seqs)
# med_seqs <- sapply(med_seqs, FUN = str_replace, "-+", "")
# names(med_seqs) <- paste0("Node_", sapply(str_split(names(med_seqs), "\\|"), FUN = `[`, 1))  # remove size annotation

# remove chimeras from MED sequences with DADA2 method
# DADA2 method
# med_seqtab <- t(med_table)
# colnames(med_seqtab) <- med_seqs
# med_seqtab.no_chim <- removeBimeraDenovo(med_seqtab)
# med_table.no_bim <- med_table[med_seqs %in% colnames(med_seqtab.no_chim), ]

# remove chimeras detected with UCHIME method
# med_seqs.chimeras <- readDNAStringSet(file.path(result_path, "med/uchime/NODE-chimeras.fasta"))
# if (length(med_seqs.chimeras) > 0){
#   med_seqs.chimeras <- as.character(med_seqs.chimeras)
#   names(med_seqs.chimeras) <- paste0("Node_", sapply(str_split(names(med_seqs.chimeras), ";"), FUN = `[`, 1))
#   med_table <- med_table[!med_seqs %in% med_seqs.chimeras, ]
#   med_table
#   med_seqs <- med_seqs[!med_seqs %in% med_seqs.chimeras]
# }
# 
# med_table <- med_table[apply(med_table[, sample_names], 1, max) > 1, ]  # remove singletons
write_tsv(med_table %>% select(-sequence), file.path(result_path, "med/med_table.txt"))

# med_table$sequence <- med_seqs[med_table$id]  # add sequences to table
# med_seqs <- med_seqs[med_table$id]

```


```{r load Deblur table}

# load Deblur table
deblur_otu_file <- file.path(result_path, "deblur/all.txt")
deblur_table <- load_deblur(deblur_otu_file)

# deblur_table <- as.tibble(read.table(file = file.path(result_path, "deblur/all.txt"), header = TRUE, sep = "\t", 
#                                      skip = 1, comment.char = ""))
# colnames(deblur_table)[1] <- "id"
# deblur_seqs <- toupper(deblur_table$id)  
# names(deblur_seqs) <- paste0("sOTU_", 1:length(deblur_seqs))
# deblur_table$id <- names(deblur_seqs)
# deblur_table <- deblur_table %>% select(id, sample_names)
# deblur_table <- deblur_table[apply(deblur_table[, sample_names], 1, max) > 1, ]  # remove singletons
deblur_table
write_tsv(deblur_table %>% select(-sequence), file.path(result_path, "deblur/deblur_table.txt"))

# deblur_table$sequence <- deblur_seqs[deblur_table$id]  # add sequences to table
# deblur_seqs <- deblur_seqs[deblur_table$id]

```


```{r load DADA2 table}

# load DADA2 table
dada2_otu_file <- file.path(result_path, "dada2/sv_table.no_chim.txt")
dada2_table <- load_dada2(dada2_otu_file, min_abund = 10)

# dada2_table <- read.table(file = file.path(result_path, "dada2/sv_table.no_chim.txt"), header = TRUE, sep = "\t")
# dada2_table <- data.frame(t(dada2_table))
# dada2_table <- as.tibble(rownames_to_column(dada2_table, var = "id"))
# dada2_seqs <- dada2_table$id
# names(dada2_seqs) <- paste0("ASV_", 1:length(dada2_seqs))
# dada2_table$id <- names(dada2_seqs)
# dada2_table <- dada2_table[apply(dada2_table[, sample_names], 1, max) > 1, ]  # remove singletons
dada2_table
write_tsv(dada2_table %>% select(-sequence), file.path(result_path, "dada2/dada2_table.txt"))

# dada2_table$sequence <- dada2_seqs[dada2_table$id]  # add sequences to table
# dada2_seqs <- dada2_seqs[dada2_table$id]

```


##Create and annotate a list of method tables

Create a list of method tables.
```{r create method table list}

methods <- c("uclust", "uparse", "unoise", "med", "deblur", "dada2")
method_tables <- list(uclust_table, uparse_table, unoise_table, med_table, deblur_table, dada2_table)
names(method_tables) <- methods

```

Read in reference sequences, and define a function to compute Levenshtein (Hamming + indels) distance between two sequences.
```{r Levenshtein function}

ref_fastas <- list.files(ref_path, pattern = "_16S.fasta$")
ref_seqs <- readDNAStringSet(file.path(ref_path, ref_fastas)) %>% as.character()
strains <- sapply(str_split(names(ref_seqs), "_16S"), `[`, 1)

# define a function to compute Levenshtein distances between two sequences
# levDist <- Vectorize(function(query, ref, ...) {
#   mmi <- dada2:::nweval(query, ref, ...)    # this gives matches, mismatches, and indels
#   ldist <- mmi[2] + mmi[3]
#   if (nchar(query) > sum(mmi)) {    # query not fully overlapped by reference
#     ldist <- nchar(query) - mmi[1]  # include non-overlapped nucleotides in distance
#   }
#   return(ldist)
# })

```


Compute distances of inferred sequences to the reference sequences for each method.
```{r compute method distances}

dist_tables <- lapply(method_tables, compute_dist_to_ref, ref_seqs)

# dist_tables2 <- lapply(method_tables, function(mtab){
#   seqs_to_ref <- outer(mtab$sequence, ref_seqs, levDist, band = -1)
#   row.names(seqs_to_ref) <- mtab$id
#   return(seqs_to_ref)
# })

strain_dist_tables <- lapply(dist_tables, collapse_group_dist, strains)

# strain_dist_tables <- lapply(dist_tables2, function(dtab){
#   strains_to_ref <- t(aggregate(t(dtab), list(strains), min))
#   colnames(strains_to_ref) <- strains_to_ref[1, ]
#   strains_to_ref <- strains_to_ref[-1, ]
#   class(strains_to_ref) <- "integer"
#   return(strains_to_ref)
# })

```


Write functions to count and identify sequences that differ by 1 (or more) necleotides from a more abundant reference sequence.
```{r noisy functions}

# # function to generate a table of "noisy"" sequences: those that are very similar to the reference sequences
# countNoisySeqs <- function(seq_tab, dist_mat, min_dist = 1, max_dist = 3) {
#   if (max(colSums(dist_mat == 0)) > 1) {
#     print("WARNING: Your distance matrix contains seqeunces that are identical except for length differences.")
#     print("This may result in inaccurate counts of noisy seuqences.")
#   }
#   
#   if (sum(!sapply(seq_tab, class) %in% c("integer", "numeric")) > 0){
#     stop("The sequence table must only contain column vectors of type 'numeric' or 'integer'.")
#   }
#   
#   rmat <- matrix(0, nrow = ncol(seq_tab), ncol = (max_dist - min_dist) + 1, 
#                  dimnames = list(colnames(seq_tab), paste0(min_dist:max_dist, "_off")))
#   
#   for (n in min_dist:max_dist){
#     mins <- apply(dist_mat, 1, min)   
#     noisy_ind <- which(dist_mat == n, arr.ind = TRUE)
#     noisy_ind <- noisy_ind[dist_mat[noisy_ind] == mins[noisy_ind[, "row"]], , drop = FALSE]   # make sure it's a minimum distance
#     has_zero <- apply(dist_mat[, noisy_ind[, "col"], drop = FALSE], 2, min) == 0  # is there a hit to the nearest reference?
#     noisy_ind <- noisy_ind[has_zero, , drop = FALSE]
#     
#     if (length(noisy_ind) > 0){
#       ref_row <- apply(dist_mat[, noisy_ind[, "col"] , drop = FALSE] == 0, 2, which)  # get nearest sequence that matches reference
#       noisy_ind <- cbind(noisy_ind, ref_row)
#       is_n_off <- ( (seq_tab[noisy_ind[, "row"], ] > 0) & 
#                    (seq_tab[noisy_ind[, "row"], ] < seq_tab[noisy_ind[, "ref_row"], ]) ) * 1  # is abundance less than reference?
#       row.names(is_n_off) <- row.names(noisy_ind)
#       is_n_off <- aggregate(is_n_off, by = list(row.names(is_n_off)), FUN = max)
#       row.names(is_n_off) <- is_n_off$Group.1
#       is_n_off <- is_n_off[, -1]
#       rmat[, n] <- colSums(is_n_off)
#     }
#     else rmat[, n] <- integer(nrow(rmat))
#   }
#   rmat <- cbind(rmat, "ref_noisy" =  rowSums(rmat))
#   return(rmat)
# }
# 
# # define a function that returns whether sequences of a sequence table are "noisy"
# isRefNoisy <- function(seq_tab, dist_mat, min_dist = 1, max_dist = 3){
#   if (max(colSums(dist_mat == 0)) > 1) {
#     print("WARNING: Your distance matrix contains seqeunces that are identical except for length differences.")
#     print("This may result in inaccurate counts of noisy seuqences.")
#   }
#   
#   if (sum(!sapply(seq_tab, class) %in% c("integer", "numeric")) > 0){
#     stop("The sequence table must only contain column vectors of type 'integer' or 'numeric'.")
#   }
#   
#   mins <- apply(dist_mat, 1, min)   # get minimum distance for each sequence
#   noisy_ind <- which(dist_mat >= min_dist & dist_mat <= max_dist, arr.ind = TRUE) 
#   if (length(noisy_ind) == 0){
#     return(rep(FALSE, nrow(dist_mat)))
#   } 
#   else {
#     noisy_ind <- noisy_ind[dist_mat[noisy_ind] == mins[noisy_ind[, "row"]], , drop = FALSE]   # make sure it's a minimum distance
#     has_zero <- apply(dist_mat[, noisy_ind[, "col"], drop = FALSE], 2, min) == 0  # is there a hit to the nearest reference?
#     noisy_ind <- noisy_ind[has_zero, , drop = FALSE]
#     ref_row <- apply(dist_mat[, noisy_ind[, "col"] , drop = FALSE] == 0, 2, which)   # find the nearest sequence that matches the reference
#     noisy_ind <- cbind(noisy_ind, ref = ref_row)
#     is_noisy <- ( (seq_tab[noisy_ind[, "row"], ] > 0) & 
#                     (seq_tab[noisy_ind[, "row"], ] < seq_tab[noisy_ind[, "ref"], ]) )   # is abundance less than reference?
#     is_noisy <- apply(is_noisy, 1, any)   # collapse to vector
#     noisy_ind <- noisy_ind[is_noisy, , drop = FALSE]    # remove any with abundance higher than reference
#     noisy <- 1:nrow(dist_mat) %in% noisy_ind[, "row"]  
#     return(noisy)
#   }
# }

```


Annotate sequences in sequence tables as "reference" if they exactly match a reference sequence, or as "ref_noisy" if they are within a specified Levenshtein distance range from a reference sequence. 
```{r annotate method reference}

method_tables <- mapply(annotate_ref, method_tables, dist_tables, 
                        MoreArgs = list(sample_names = sample_names, max_dist = 3),
                        SIMPLIFY = FALSE)

# method_tables <- mapply(function(meth_tab, dist_tab){
#   # What's the shortest distance to any reference sequence?
#   meth_tab$dist_to_ref <- apply(dist_tab, 1, min) 
#   # Does the sequence exactly match a reference sequence?
#   meth_tab$reference <- meth_tab$dist_to_ref == 0
#   # If not, is the sequence within 3 nucleotides of a reference sequence?
#   meth_tab$ref_noisy <- isRefNoisy(meth_tab[, sample_names], dist_tab, 1, 3)
#   # Is the sequence most likely derived from a reference sequence (exact or near match)?
#   meth_tab$ref_like <- meth_tab$reference | meth_tab$ref_noisy
#   return(meth_tab)
# }, method_tables, dist_tables, SIMPLIFY = FALSE)


```


Next, write each method's inferred (singleton-free) sequences to a fasta file, for BLASTing against nt.
```{r write fastas}

mapply(write_fasta, method_tables, file.path(analysis_path, paste(methods, "seqs.fasta", sep = "_")))

# mapply(function(mtab, m){
#   seqs <- DNAStringSet(mtab$sequence)
#   names(seqs) <- mtab$id
#   fname <- paste(m, "seqs.fasta", sep = "_")
#   writeFasta(seqs, file.path(analysis_path, fname))
# }, method_tables, methods)

# BLAST each method's sequences against the 'nt' database using the following command:
# blastn -query method_seqs.fasta -db nt -out method_blast.txt \
#        -task megablast -max_target_seqs 10 \
#        -outfmt "7 qseqid qlen sseqid slen sskingdoms ssciname pident length nident mismatch gapopen gaps qstart qend sstart send evalue bitscore" \
#        -remote

```


Read in the results of the BLAST searches.
```{r load blast tables}

blast_files <- file.path(analysis_path, paste(methods, "blast.txt", sep = "_"))
blast_tables <- lapply(blast_files, load_blast)

# blast_tables <- lapply(methods, function(m){
#   fname <- paste(m, "blast.txt", sep = "_")
#   btab <- as.tibble(read.table(file.path(analysis_path, fname), sep = "\t", comment.char = "#",
#                                col.names = c("seqID", "seq_len", "subjectID", "subject_len", "kingdom", "sci_name", 
#                                              "identity", "aln_len", "matches", "mismatches", "gapopens", "gaps", 
#                                              "qstart", "qend", "sstart", "send", "evalue", "bitscore")))
#   return(btab)
# })
names(blast_tables) <- methods

```

Define functions to identify blast hits that are exact matches and those that are one or more nucleotides off.
```{r blast parsing functions}

# isBlastHit <- function(seq_tab, blast_tab){
#    perfect_hits <- blast_tab[ (blast_tab$identity == 100) & 
#                                (blast_tab$seq_len == blast_tab$aln_len), ]
#   return(seq_tab$id %in% perfect_hits$seqID)
# }
# 
# 
# isBlastNoisy <- function(seq_tab, blast_tab, min_off = 1, max_off = 3){
#   # annotate blast table to facilitate computation of differences between query and subject (nt) sequences
#   blast_tab$lev_dist <- blast_tab$mismatches + blast_tab$gaps  # compute Levenshtein distances, not counting terminal gaps
#   blast_tab$cov_dist <- pmax(blast_tab$seq_len - blast_tab$aln_len, 0)  # compute number of terminal gaps, if any
#   blast_tab$tot_dist <- blast_tab$lev_dist + blast_tab$cov_dist  # sum the two to get the total distance between sequences
#   
#   noisies <- blast_tab[between(blast_tab$tot_dist, min_off, max_off), ]
#   is_noisy <- seq_tab$id %in% noisies$seqID
#   
#   hits <- isBlastHit(seq_tab, blast_tab)
#   is_noisy[hits] <- FALSE
#   
#   return(is_noisy)
# }

```


Annotate sequence tables with results from BLAST analysis.
```{r annotate method contaminant}

method_tables <- mapply(annotate_contam, method_tables, blast_tables, 
                        MoreArgs = list(sample_names), SIMPLIFY = FALSE)
method_tables <- lapply(method_tables, function(mt){
  mt <- mt %>% select(-sequence, sequence)
  return(mt)
})

# method_tables <- mapply(function(mtab, btab){
#   mtab$contaminant <- isBlastHit(mtab, btab) & !mtab$ref_like
#   mtab$contam_noisy <- isBlastNoisy(mtab, btab, 1, 3) & !mtab$ref_like
#   mtab$contam_like <- mtab$contaminant | mtab$contam_noisy
#   mtab$other <- !mtab$ref_like & !mtab$contam_like
#   return(mtab)
# }, method_tables, blast_tables, SIMPLIFY = FALSE)
# 
# # Annotate "consensus" sequences-- that are observed in every sample
# method_tables <- lapply(method_tables, function(mtab, snames){
#   mtab$consensus <- apply(mtab[, snames], 1, min) > 0
#   return(mtab)
# }, sample_names)

```


##Create a list of tables that summarize method results

Compute summary tables for each method, with total sequence counts, sequence counts in each class, and percentages of reads in each class.
```{r compute method summaries}

method_summary <- mapply(summarize_seqs, method_tables, dist_tables, 
                         MoreArgs = list(sample_names = sample_names, strains = strains),
                         SIMPLIFY = FALSE)

# method_summary <- mapply(function(meth_tab, dist_tab, dist_sp_tab, snames){
#   # summarize counts of various classes
#   exp_strains <- rep(length(unique(strains)), length(sample_names))
#   m_total <- colSums(meth_tab[, snames] > 0)   # total number of sequences
#   m_strains <- integer()
#   for (s in snames){
#     s_strains <- sum(apply(dist_sp_tab[meth_tab[, s] > 0, ], 2, min) == 0)
#     m_strains <- c(m_strains, s_strains)
#   }
#   m_refs <- colSums(meth_tab$reference & meth_tab[, snames] > 0)
#   m_ref_noisy <- countNoisySeqs(meth_tab[, snames], dist_tab, 1, 3)   # "ref_noisy" sequences
#   m_ref_like <- m_refs + m_ref_noisy[, "ref_noisy"]
#   m_contam <- colSums(meth_tab$contaminant & meth_tab[, snames] > 0)  # exact BLAST hits
#   m_contam_noisy <- colSums(meth_tab$contam_noisy & meth_tab[, snames] > 0)  # "contam_noisy"
#   m_contam_like <- m_contam + m_contam_noisy
#   m_other <- colSums(!meth_tab$ref_like & !meth_tab$contam_like & meth_tab[, snames] > 0)   # non-refs, not "ref_noisy"
#   
#   # summarize percentage of primary classes
#   m_pct_ref <- 100 * colSums(meth_tab[meth_tab$reference, snames]) / colSums(meth_tab[, snames])
#   m_pct_ref_noisy <- 100 * colSums(meth_tab[meth_tab$ref_noisy, snames]) / colSums(meth_tab[, snames])
#   m_pct_contam <- 100 * colSums(meth_tab[meth_tab$contaminant, snames]) / colSums(meth_tab[, snames])
#   m_pct_contam_noisy <- 100 * colSums(meth_tab[meth_tab$contam_noisy, snames]) / colSums(meth_tab[, snames])
#   m_pct_other <- 100 * colSums(meth_tab[meth_tab$other, snames]) / colSums(meth_tab[, snames])
# 
#   # compile summaries into a table
#   m_summary <- data.frame(sample = snames, exp_strains = exp_strains, total = m_total, 
#                           strains = m_strains, 
#                           reference = m_refs, m_ref_noisy, ref_like = m_ref_like,
#                           contaminant = m_contam, contam_noisy = m_contam_noisy, contam_like = m_contam_like,
#                           other = m_other, 
#                           pct_ref = m_pct_ref, pct_ref_noisy = m_pct_ref_noisy, 
#                           pct_contam = m_pct_contam, pct_contam_noisy = m_pct_contam_noisy, 
#                           pct_other = m_pct_other,
#                           row.names = NULL, check.names = FALSE)
#   
#   return(m_summary)
# }, method_tables, dist_tables, strain_dist_tables, MoreArgs = list(snames = sample_names), SIMPLIFY = FALSE)

```


From the summary tables, compute the following summary statistics for each method: recall, precision, false negative rate, and false discovery rate.
```{r method summary stats}

seq_stats <- lapply(method_summary, compute_pr_seqs)

# seq_stats <- lapply(method_summary, function(msum, snames){
#   TP <- msum$reference  # true positives
#   FN <- msum$exp_strains - msum$reference  # false negatives
#   FP <- msum$ref_noisy + msum$contaminant + msum$contam_noisy + msum$other  # false positives
# 
#   # compute summary stats on combined classes
#   TPR <- 100 * TP / (TP + FN)
#   PPV <- 100 * TP / (TP + FP)
# 
#   mstat <- tibble(sample = snames, TP = TP, FN = FN, FP = FP,
#                   recall = TPR, precision = PPV) 
#   return(mstat)
# }, snames = sample_names)

```


##Create and annotate a list of sample tables

First, create a summary table for each sample (all 9 dilutions).
```{r create sample table list}

sample_summary <- sapply(sample_names, function(m) NULL)

sample_summary <- mapply(function(ssum, sname, msum){
  ssum <- lapply(msum, function(ms, ss, sn) {
    ss <- rbind(ss, ms[ms$sample == sn, ])
    return(ss)
  }, ss = ssum, sn = sname)
  
  ssum <- do.call("rbind", ssum) %>% rownames_to_column(var = "method")
  ssum <- ssum %>% select(method, everything(), -sample)
  return(ssum)
}, sample_summary, sample_names, MoreArgs = list(msum = method_summary), SIMPLIFY = FALSE)

```


```{r the long way}

# # combine sequences from all methods
# all_seqs <- lapply(method_tables, `[[`, "sequence") %>% do.call("c", .) %>% unique()
# 
# # create sequence tables for each dilution sample
# dilution_tables_t <- lapply(sample_names, function(sn, seqs, meths, meth_tabs){
#   # create a sequence table
#   stab <- matrix(as.integer(0), ncol = length(seqs), nrow = length(meths))
#   colnames(stab) <- seqs
#   row.names(stab) <- meths
#   
#   # populate the sequence table with sample abundances
#   for (i in seq_along(meths)){
#     stab[meths[i], meth_tabs[[i]]$sequence] <- meth_tabs[[i]][[sn]]
#   }
#   
#   # remove sequences with all zero abundances
#   stab <- stab[, colSums(stab) > 0]
#   # collapse seqeunces that only differ in length
#   stab <- collapseNoMismatch(stab)
#   #convert to tibble
#   stab <- stab %>% t() %>% data.frame() %>% rownames_to_column(var = "sequence") %>% as.tibble()  # data.frame(t(stab)) 
#   
#   return(stab)
# }, seqs = all_seqs, meths = methods, meth_tabs = method_tables)
# 
# names(dilution_tables_t) <- sample_names

```


Next, compute distances from each sample sequence to the reference sequences.
```{r compute sample distances}

# # create tables for each sample of Levenshtein distances to reference sequences
# dilution_to_ref_t <- lapply(dilution_tables_t, function(dt, refs){
#   s_to_ref <- outer(dt$sequence, refs, levDist, band = -1)
#   row.names(s_to_ref) <- dt$sequence
#   return(s_to_ref)
# }, refs = ref_seqs)
# 
# # Collapse distances for strains of the same species (using minimum distance)
# dilution_to_ref_strains_t <- lapply(dilution_to_ref_t, function(s_to_ref, sp){
#   s_to_ref_sp <- t(aggregate(t(s_to_ref), list(sp), min))
#   colnames(s_to_ref_sp) <- s_to_ref_sp[1, ]
#   s_to_ref_sp <- s_to_ref_sp[-1, ]
#   class(s_to_ref_sp) <- "integer"
#   return(s_to_ref_sp)
# }, sp = strains)


```


Now annotate sample tables with "reference" and "ref_noisy".
```{r annotate sample reference}

# # annotate sample sequence tables
# dilution_tables_t <- mapply(function(dt, d_to_ref, meths){
#   dt$dist_to_ref <- apply(d_to_ref, 1, min)
#   dt$reference <- dt$dist_to_ref == 0
#   dt$ref_noisy <- isRefNoisy(dt[, meths], d_to_ref)
#   dt$ref_like <- dt$reference | dt$ref_noisy
#   return(dt)
# }, dilution_tables_t, dilution_to_ref_t, MoreArgs = list(meths = methods), SIMPLIFY = FALSE)

```


Next I want to annotate the sample tables with BLAST results, but since the BLAST tables are per method, I need to modify them so I can cross-reference results according to sequences for a given sample instead of a given method.
```{r modify BLAST results}

# # add sequences to BLAST tables
# blast_tables <- mapply(function(bt, mt){
#   bt$sequence <- mt[match(bt$seqID, mt$id), ] %>% .[["sequence"]]
#   return(bt)
# }, blast_tables, method_tables, SIMPLIFY = FALSE)

```


Compute a summary table for each sample.
```{r compute sample summaries}

# # compute sample summary tables
# dilution_summary_t <- mapply(function(stab, s_to_ref, s_to_ref_strains, meths){
#   # summarize counts of various classes
#   s_total <- colSums(stab[, meths] > 0)
#   s_strains <- integer()
#   for (m in methods){
#     m_strains <- sum(apply(s_to_ref_strains[stab[[m]] > 0, ], 1, min) == 0)
#     s_strains <- c(s_strains, m_strains)
#   }
#   s_ref <- colSums(stab$reference & stab[, meths] > 0)
#   s_ref_noisy <- countNoisySeqs(stab[, meths], s_to_ref, 1, 3)   # "ref_noisy" sequences
#   s_other <- colSums(stab$dist_to_ref > 3 & stab[, methods] > 0)   # non-hits, not "ref_noisy"
#   
#   # summarize percentages of primary classes
#   s_pct_ref <- colSums(stab[stab$reference, meths]) / colSums(stab[, meths])
#   s_pct_ref_noisy <- colSums(stab[stab$ref_noisy, meths]) / colSums(stab[, meths])
#   s_pct_other <- colSums(stab[!stab$reference & ! stab$ref_noisy, meths]) / colSums(stab[, meths])
# 
#   # compile summaries into a table
#   s_summary <- data.frame(method = meths, total = s_total, strains = s_strains,
#                           reference = s_ref, s_ref_noisy, other = s_other, 
#                           pct_ref = s_pct_ref, pct_ref_noisy = s_pct_ref_noisy,
#                           pct_other = s_pct_other,
#                           row.names = NULL, check.names = FALSE)
#   return(s_summary)
# }, dilution_tables_t, dilution_to_ref_t, dilution_to_ref_strains_t, MoreArgs = list(meths = methods), SIMPLIFY = FALSE)


# dilution_table <- list()
# dilution_to_ref <- list()
# dilution_summary <- list()
# 
# for (i in seq_along(sample_names)){
#   # create a sequence table for the sample
#   sample_st <- matrix(as.integer(0), ncol = length(all_seqs), nrow = length(methods))
#   colnames(sample_st) <- all_seqs
#   row.names(sample_st) <- methods
#   
#   # populate the table with sample abundances
#   sample_st["uclust", uclust_table$sequence] <- uclust_table[[ sample_names[i] ]]
#   sample_st["uparse", uparse_table$sequence] <- uparse_table[[ sample_names[i] ]]
#   sample_st["unoise", unoise_table$sequence] <- unoise_table[[ sample_names[i] ]]
#   sample_st["med", med_table$sequence] <- med_table[[ sample_names[i] ]]
#   sample_st["deblur", deblur_table$sequence] <- deblur_table[[ sample_names[i] ]]
#   sample_st["dada2", dada2_table$sequence] <- dada2_table[[ sample_names[i] ]]
# 
#   # remove columns (sequences) with all zeros
#   sample_st <- sample_st[, colSums(sample_st) > 0]
#   
#   # collapse sequences that only differ in length
#   sample_st <- collapseNoMismatch(sample_st)
#   
#   # Compute distances from sample sequences to reference
#   sample_to_ref <- outer(colnames(sample_st), ref_seqs, levDist, band = -1)
#   row.names(sample_to_ref) <- colnames(sample_st)
#   # Collapse distances for strains of the same species (using minimum distance)
#   sample_to_ref_strains <- t(aggregate(t(sample_to_ref), list(strains), min))
#   colnames(sample_to_ref_strains) <- sample_to_ref_strains[1, ]
#   sample_to_ref_strains <- sample_to_ref_strains[-1, ]
#   class(sample_to_ref_strains) <- "integer"
# 
#   # Convert to tibble and annotate sequences
#   sample_table <- sample_st %>% t() %>% data.frame() %>% rownames_to_column(var = "sequence") %>% as.tibble()
#   sample_table$dist_to_ref <- apply(sample_to_ref, 1, min)
#   sample_table$reference <- sample_table$dist_to_ref == 0
#   sample_table$ref_noisy <- isRefNoisy(sample_table[, methods], sample_to_ref)
#   sample_table$other <- !sample_table$reference & !sample_table$ref_noisy
#   
#   # Compute summary statistics
#   sample_refs <- colSums(sample_table$reference & sample_table[, methods] > 0)
#   sample_strains <- integer()
#   for (m in methods){
#     m_strains <- sum(apply(sample_to_ref_strains[sample_table[[m]] > 0, ], 1, min) == 0)
#     sample_strains <- c(sample_strains, m_strains)
#   }
#   sample_total <- colSums(sample_table[, methods] > 0)   # total number of sequences
#   sample_noisy <- countNoisySeqs(sample_table[, methods], sample_to_ref, 1, 3)   # "noisy" sequences
#   sample_other <- colSums(sample_table$dist_to_ref > 3 & sample_table[, methods] > 0)   # non-refs, not "noisy"
#   
#   sample_pct_ref <- colSums(sample_table[sample_table$reference, methods]) / colSums(sample_table[, methods])
#   sample_pct_ref_noisy <- colSums(sample_table[sample_table$ref_noisy, methods]) / colSums(sample_table[, methods])
#   sample_pct_other <- colSums(sample_table[sample_table$other, methods]) / colSums(sample_table[, methods])
# 
#   sample_summary <- data.frame(method = methods, total = sample_total, strains = sample_strains,
#                                reference = sample_refs, sample_noisy, other = sample_other, 
#                                pct_ref = sample_pct_ref, pct_ref_noisy = sample_pct_ref_noisy,
#                                pct_other = sample_pct_other,
#                                row.names = NULL, check.names = FALSE)
#   
#   dilution_table[[i]] <- sample_table
#   dilution_to_ref[[i]] <- sample_to_ref
#   dilution_summary[[i]] <- sample_summary
#   cat("Done with sample", sample_names[i], "\n")
# }
# 
# names(dilution_table) <- sample_names
# names(dilution_to_ref) <- sample_names
# names(dilution_summary) <- sample_names

```


##Create various plots to visualize results

Reformat annotated sequence tables for plotting with `ggplot`.
```{r prep for ggplot}

# Combine all method tables into one large table, then gather the sample columns into a single column
method_tables_gg <- lapply(method_tables, gather_samples, sample_names, "sample")
method_tables_gg <- lapply(method_tables_gg, annotate_norms, group = "sample")
# all_table_gg <- do.call("rbind", method_tables) %>% mutate(method = rep(methods, times = sapply(method_tables, nrow)))
# all_table_gg <- gather(all_table_gg, "sample", "count", one_of(sample_names)) %>% select(-sequence, id, sample, count, everything())
# all_table_gg <- annotate_norms(all_table_gg, groups = c("method", "sample"))

# all_table_gg <- all_table_gg %>% group_by(method, sample) %>% 
#   mutate(tot_reads = sum(count), rel_count = count / tot_reads) %>% 
#   ungroup() %>% group_by(method) %>%
#   mutate(norm_median = round(rel_count * median(tot_reads)), log10_norm_med = log10(norm_median)) %>% 
#   ungroup() %>%
#   select(-sequence, -tot_reads, sequence)
# medians <- sapply(method_tables, function(mt, snames) median(colSums(mt[, snames])), 
#                   snames = sample_names)


# methods_gg <- mapply(function(mt, snames){
#   mt_gg <- gather(mt, "sample", "count", one_of(snames))
#   mt_gg <- mt_gg %>% mutate(log10_count = log10(count))
#   mt_gg <- mt_gg %>% group_by(sample) %>%
#     mutate(total_reads = sum(count),
#            rel_count = count / total_reads) %>%
#     ungroup() %>% 
#     mutate(norm_median = round(rel_count * median(total_reads)),
#            log10_norm_med = log10(norm_median))
#   mt_gg <- mt_gg %>% select(id, sample, count, everything()) %>% select(-sequence, -total_reads, sequence)
#   return(mt_gg)
# }, mt = method_tables, MoreArgs = list(snames = sample_names), SIMPLIFY = FALSE)

all_table_gg <- do.call("rbind", method_tables_gg) %>% mutate(method = rep(methods, times = sapply(method_tables_gg, nrow)))

```


Now, compute the same statistics for the reads assigned to sequences in the various classes.
```{r method read summary stats}

read_stats <- lapply(method_tables_gg, compute_pr_reads, group = "sample")

# write_tsv(read_stats, path = file.path(analysis_path, "dilution_read_stats.tsv"))

```


Create tables of sequence and read count summaries per sample and method.
```{r summary tables}

load(file.path(result_path, "dada2/tables.RData"))
median_raw <- median(track_table[, "raw"])

sample_seq_count_gg <- sapply(method_tables, function(st, ss) colSums(st[, ss] > 0), sample_names) %>%
  t() %>% as.data.frame() %>% rownames_to_column(var = "method") %>% as.tibble()
sample_seq_count_gg <- gather(sample_seq_count_gg, "sample", "seqs", -method)

sample_read_count_gg <- sapply(method_tables, function(st, ss) colSums(st[, ss]), sample_names) %>%
  t() %>% as.data.frame() %>% rownames_to_column(var = "method") %>% as.tibble()
sample_read_count_gg <- gather(sample_read_count_gg, "sample", "reads", -method)

sample_counts_gg <- merge(sample_read_count_gg, sample_seq_count_gg, by = c("method", "sample"))
sample_counts_gg <- sample_counts_gg %>% group_by(method) %>% 
  mutate(seqs_norm_method_median = round(seqs * median(reads) / reads),
         seqs_norm_raw_median = round(seqs * median_raw / reads)) %>%
  ungroup()

# Calculate mean signal strengths of each method's reference and non-reference sequences
# sample_snr <- lapply(method_tables, function(mt){
#   snr_mean <- mt[, sample_names] %>% sapply(., tapply, mt$reference, function(x) mean(log10(x[x > 0])))
#   snr_mean <- as.tibble(rownames_to_column(as.data.frame(snr_mean), var = "reference"))
#   return(snr_mean)
# })
sample_snr <- lapply(method_tables, function(mt){
  snr_mean <- mt[, sample_names] %>% sapply(., tapply, mt$reference, function(x) mean(log10(x[x > 0])))
  snr_mean <- snr_mean["TRUE", ] / snr_mean["FALSE", ]
  #snr_mean <- as.tibble(rownames_to_column(as.data.frame(snr_mean), var = "reference"))
  return(snr_mean)
})
sample_snr <- do.call("rbind", sample_snr) %>% as.data.frame %>% rownames_to_column(var = "method") %>% as.tibble
#sample_snr$reference <- as.logical(sample_snr$reference)
#sample_snr$method <- rep(methods, each = 2)
sample_snr_gg <- gather(sample_snr, "sample", "mean_snr", one_of(sample_names))
sample_snr_gg 

sample_counts_gg <- merge(sample_counts_gg, sample_snr_gg, by = c("method", "sample")) %>% as.tibble()


# Create plotting labels
dilution_labels <- sapply(str_split(sample_names, "\\."), function(d){
  paste(d[3:4], collapse = ":")
})
dilution_labels[1] <- "1:1"
dilution_values <- sapply(str_split(dilution_labels, ":"), function(d) as.numeric(d[1]) / as.numeric(d[2]))


```


Compute Bray-Curtis similarity between each dilution sample and the neat sample, for each method.
```{r Bray-Curtis}

# normalize sequence table by median read count per method
norm_median_tables <- lapply(method_tables, function(table){
  seq_tab <- table[table$reference, c("id", sample_names)]
  medn <- median(colSums(seq_tab[, sample_names]))
  seq_tab[, sample_names] <- sapply(seq_tab[, sample_names], function(x) round(medn * (x / sum(x))))
  seq_tab <- as.tibble(seq_tab)
  return(seq_tab)
})

# compute Bray-Curtis similarity relative to neat sample
bray_curtis <- lapply(norm_median_tables, function(table){
  neat <- table[[sample_names[1]]]
  bc <- sapply(table[, sample_names], function(sample){
    return(2 * sum(pmin(neat, sample)) / (sum(neat) + sum(sample)))
  })
  return(bc)
})

bray_curtis <- do.call("rbind", bray_curtis) %>% as.tibble() %>% mutate(method = methods) %>% select(method, everything())

```


Create stacked histograms showing numbers of sequences vs. read count for reference and non-reference sequences.
```{r read count histograms}

library(ggridges)

sname = sample_names[9]
min_count = 100

read_hist <- ggplot(all_table_gg %>% filter(sample == sname, count > min_count), 
                    aes(x = count, y = reference)) +
  geom_density_ridges(aes(fill = reference, height = ..density..), scale = 0.9, stat = "binline", bins = 120, panel_scaling = FALSE) +
  geom_vline(data = all_table_gg %>% filter(sample == sname, reference) %>% group_by(method) %>% summarise(min = min(count)), aes(xintercept = min)) +
  facet_wrap(~method) +
  scale_fill_brewer(palette = "Dark2")
read_hist

```


Create plots to show relative strength of signal (reference sequence matches) to noise (non-reference sequences).
```{r snr plots}

theme_set(theme_bw())

mname = "deblur"

# ref vs. non-ref boxplots, raw counts
snr_box <- ggplot(data = all_table_gg %>% filter(method == mname)) +
  geom_boxplot(aes(x = sample, y = log10_norm_med, fill = factor(reference, levels = c(TRUE, FALSE)))) +
  labs(title = "Distribution of log10(read counts) for reference and non-reference sequences",
          subtitle = paste("Dilution series processed with", mname), x = "sample dilution", y = "log10(read counts)") +
  scale_fill_manual(name = "sequence identity", labels = c("reference", "non-reference"), values = c("blue", "orange")) +
  scale_x_discrete(labels = dilution_labels) +
  theme(legend.position = c(0.95, 0.05),
        legend.justification = c(1, 0))
snr_box

# ref vs. non-ref violin plots, raw counts
snr_violin <- ggplot(data = all_table_gg %>% filter(method == mname)) +
  geom_violin(aes(x = sample, y = log10_norm_med, fill = factor(reference, levels = c(T, F)))) +
  labs(title = "Density distribution of log10(read counts) for reference and non-reference sequences",
          subtitle = paste("Dilution series processed with", mname), x = "sample dilution", y = "log10(read counts)") +
  scale_fill_manual(name = "sequence identity", labels = c("reference", "non-reference"), values = c("blue", "orange")) +
  scale_x_discrete(labels = dilution_labels) +
  theme(legend.position = c(0.95, 0.05),
        legend.justification = c(1, 0))
snr_violin

# ref vs. non-ref beeswarm plots, raw counts
snr_bees <- ggplot(data = all_table_gg %>% filter(method == mname)) +
  geom_beeswarm(aes(x = sample, y = log10_norm_med, color = factor(reference, levels = c(T, F))), dodge.width = 0.75) +
  labs(title = "Density distribution of log10(read counts) for reference and non-reference sequences",
          subtitle = paste("Dilution series processed with", mname), x = "method", y = "log10(read counts)") +
  scale_color_manual(name = "sequence identity", labels = c("reference", "non-reference"), values = c("blue", "orange")) +
  scale_x_discrete(labels = dilution_labels) +
  theme(legend.position = c(0.95, 0.05),
        legend.justification = c(1, 0))
snr_bees

# average (mean(log10)) of ref vs. non-ref signal
# mean_snr_line <- ggplot(sample_sn_gg, aes(x = sample, y = mean_log10)) +
#   geom_point(data = subset(sample_sn_gg, reference), aes(color = method, group = method)) +
#   geom_line(data = subset(sample_sn_gg, reference), aes(color = method, group = method)) + 
#   geom_point(data = subset(sample_sn_gg, !reference), aes(color = method, group = method)) +
#   geom_line(data = subset(sample_sn_gg, !reference), aes(color = method, group =method))
# mean_snr_line

mean_snr_line <- ggplot(sample_counts_gg, aes(x = sample, y = mean_snr)) +
  geom_point(aes(color = method, group = method)) +
  geom_line(aes(color = method, group = method)) +
  scale_x_discrete(labels = dilution_labels) +
  scale_color_brewer(palette = "Dark2")
mean_snr_line

```

Create plot to show sample composition, colored by reference vs. non-reference.
```{r composition plot}

library(RColorBrewer)

mname = "uclust"

set.seed(444)
data_table <- method_tables[[mname]]
data_gg <- all_table_gg %>% filter(method == mname)

ref_colors <- brewer.pal(sum(data_table$reference), "Dark2")
other_colors <- sample(grey.colors(5, start = 0.5, end = 0.9), sum(!data_table$reference), replace = TRUE)

data_table$color <- rep(NA, nrow(data_table))
data_table$color[data_table$reference] <- ref_colors
data_table$color[!data_table$reference] <- other_colors

color_gg <- data_table %>% select(id, sample_names, color) %>% gather("sample", "count", sample_names)
legend_color <- c(bright = ref_colors[2], dull = other_colors[2])
data_gg <- inner_join(data_gg, color_gg)

comp_bar <- ggplot(data_gg, aes(x = sample, y = count)) +
  geom_col(aes(fill = color, group = reference, alpha = ifelse(reference, "bright", "dull")), width = 0.5, position = position_fill()) +
  scale_fill_identity(guide = FALSE) +
  scale_alpha_manual(name = "Sequence type", 
                     labels = c("mock community", "other"),
                     values = c(bright = 1, dull = 1), 
                     guide = guide_legend(override.aes = list(fill = c(ref_colors[4], "#AEAEAE")), 
                                          keywidth = NULL, keyheight = NULL)) +
  scale_x_discrete(labels = dilution_labels) +
  labs(title = "Relative composition of dilution series samples", 
       subtitle = paste("Dilution series processed with", mname), x = "sample dilution", y = "fraction of sample") +
  theme(legend.position = "right", legend.title = element_text(size = 12), 
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 16),
        plot.title = element_text(size = 20))
comp_bar
#comp_bar + coord_polar(theta = "y", start = 0)

```

Plot number of inferred sequences for each sample and each method.
```{r sequence count plots}

# un-normalized counts from each method
seqs_line_unnorm <- ggplot(sample_counts_gg, aes(x = sample, y = seqs)) +
  geom_point(aes(color = method), size = 2) +
  geom_line(aes(group = method, color = method)) +
  labs(title = "Number of inferred sequences/OTUs at each concentration by each method", subtitle = "Non-normalized counts",
       x = "sample dilution", y = "sequence/OTU count") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_discrete(labels = dilution_labels) +
  theme(legend.position = c(0.95, 0.95),
        legend.justification = c(1, 1))
seqs_line_unnorm

# normalized by median read count after processing by each method
seqs_line_norm <- ggplot(sample_counts_gg, aes(x = sample, y = seqs_norm_method_median)) +
  geom_point(aes(color = method), size = 2) +
  geom_line(aes(group = method, color = method)) +
  labs(title = "Number of inferred sequences/OTUs at each concentration by each method", 
       subtitle = "Normalized by median output read counts",
       x = "sample dilution", y = "sequence/OTU count") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_discrete(labels = dilution_labels) +
  theme(legend.position = c(0.95, 0.05),
        legend.justification = c(1, 0))
seqs_line_norm

# same plot as above, but only the first seven samples
seqs_line_norm_7 <- ggplot(sample_counts_gg[sample_counts_gg$sample %in% sample_names[1:7], ], aes(x = sample, y = seqs_norm_method_median)) +
  geom_point(aes(color = method)) +
  geom_line(aes(group = method, color = method)) +
  labs(title = "Number of inferred sequences/OTUs at each concentration by each method", 
       subtitle = "Normalized by median output read counts (first 7 dilutions only)",
       x = "sample dilution", y = "sequence/OTU count") +
  scale_x_discrete(labels = dilution_labels) +
  scale_color_brewer(palette = "Dark2")
seqs_line_norm_7

# normalized by median count of raw (un-processed) reads
seqs_line_norm_raw <- ggplot(sample_counts_gg, aes(x = sample, y = seqs_norm_raw_median)) +
  geom_point(aes(color = method), size = 2) +
  geom_line(aes(group = method, color = method)) +
  labs(title = "Number of inferred sequences/OTUs at each concentration by each method", 
       subtitle = "Normalized by median raw reads",
       x = "sample dilution", y = "sequence/OTU count") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_discrete(labels = dilution_labels) +
  theme(legend.position = c(0.05, 0.95),
        legend.justification = c(0, 1))
seqs_line_norm_raw

```


Plot bar plots of relative abundance of reference sequences, facetted by sample.
```{r reference seq bar plots}

mname <- "deblur"

ref_bars <- ggplot(data = all_table_gg %>% filter(reference, method == mname)) +
  geom_col(aes(x = id, y = rel_count, fill = id), width = 0.8) +
  facet_wrap(~sample) +
  scale_fill_brewer(palette = "Dark2")
ref_bars

# ref_joy <- ggplot(data = all_table_gg %>% filter(reference, method == "uclust")) +
#   geom_density_ridges(aes(x = id, y = sample, fill = id, height = ..density..), stat = "density")
# ref_joy

```


Plot read counts of reference sequences across dilutions to show whether abundances maintain their relative order.
```{r reference read counts}

mname = "dada2"

ref_lines <- ggplot(data = all_table_gg %>% filter(reference, method == mname), aes(x = sample, y = norm_median)) +
  geom_line(aes(group = id, color = id)) +
  geom_point(aes(color = id)) +
  scale_x_discrete(labels = dilution_labels) +
  scale_color_brewer(palette = "Dark2")
  #facet_wrap(~method)
ref_lines

```


Plot Bray-Curtis distances of each dilution sample's reference sequences relative to the neat sample for each method.
```{r bray-curtis lines}

bc_gg <- gather(bray_curtis, "sample", "bc_similarity", one_of(sample_names))

bc_lines <- ggplot(data = bc_gg, aes(x = sample, y = bc_similarity, color = method)) +
  geom_line(aes(group = method)) +
  geom_point() +
  scale_x_discrete(labels = dilution_labels) +
  scale_color_brewer(palette = "Dark2")
bc_lines

```


Plot distribution boxplots of non-reference read counts for "contaminant" sequences vs non-contaminant ("other") sequences.
```{r snr contaminant vs other}

mname = "dada2"

#snr_box_contam <- ggplot(dada2_gg[!dada2_gg$reference & !dada2_gg$noisy, ], aes(x = sample, y = log10_norm)) +
snr_box_contam <- ggplot(all_table_gg %>% filter(method == mname, !ref_like), aes(x = sample, y = log10_norm_med)) +
  geom_boxplot(aes(fill = factor(contam_like, levels = c(TRUE, FALSE)))) +
  labs(title = "Distribution of log10(read counts) for non-reference contaminant and non-contaminant sequences",
          subtitle = "Dilution series processed with DADA2", x = "sample dilution", y = "log10(read counts)") +
  scale_fill_manual(name = "sequence identity", labels = c("contaminant-like", "other"), values = c("blue", "orange")) +
  scale_x_discrete(labels = dilution_labels) +
  theme(legend.position = c(0.95, 0.05),
        legend.justification = c(1, 0))
snr_box_contam

```


Plot bar plots of summary stats (number of "reference", "ref_noisy", "contaminant", "other").
```{r summary stat bar plots}

all_summary_gg <- do.call("rbind", method_summary) %>% as.tibble %>% mutate(method = rep(methods, each = length(sample_names)))
all_summary_gg <- gather(all_summary_gg, "statistic", "value", -sample, -method)

ref_mean <- all_table_gg %>% filter(reference) %>% .[["count"]] %>% mean()
ref_noisy_mean <- all_table_gg %>% filter(ref_noisy) %>% .[["count"]] %>% mean()
contam_mean <- all_table_gg %>% filter(contaminant) %>% .[["count"]] %>% mean()
contam_noisy_mean <- all_table_gg %>% filter(contam_noisy) %>% .[["count"]] %>% mean()
other_mean <- all_table_gg %>% filter(other) %>% .[["count"]] %>% mean()

all_summary_gg <- all_summary_gg %>% mutate(norm_median = rep(1, nrow(all_summary_gg)))
all_summary_gg[all_summary_gg$statistic == "reference", "norm_median"] <- all_summary_gg %>% 
  filter(statistic == "reference") %>% .[["value"]] * log10(ref_mean)
all_summary_gg[all_summary_gg$statistic == "noisy", "norm_median"] <- all_summary_gg %>% 
  filter(statistic == "ref_noisy") %>% .[["value"]] * log10(ref_noisy_mean)
all_summary_gg[all_summary_gg$statistic == "contaminant", "norm_median"] <- all_summary_gg %>% 
  filter(statistic == "contaminant") %>% .[["value"]] * log10(contam_mean)
all_summary_gg[all_summary_gg$statistic == "contam_noisy", "norm_median"] <- all_summary_gg %>% 
  filter(statistic == "contam_noisy") %>% .[["value"]] * log10(contam_mean)
all_summary_gg[all_summary_gg$statistic == "other", "norm_median"] <- all_summary_gg %>% 
  filter(statistic == "other") %>% .[["value"]] * log10(other_mean)

bar_colors <- brewer.pal(9, "Set1")

summary_bars <- ggplot(data = all_summary_gg %>% filter(statistic %in% c("reference", "ref_noisy", "contaminant", "contam_noisy", "other")), 
                       aes(x = sample)) +
  geom_col(aes(y = log2(1 + value), fill = statistic), position = position_dodge()) +
  facet_wrap(~method) +
  scale_fill_manual(values = ref_colors[c(1, 3, 4, 6, 8)])
  #scale_fill_brewer(palette = "Set1")
summary_bars

summary_pct_bars <- ggplot(data = all_summary_gg %>% filter(statistic %in% c("pct_ref", "pct_ref_noisy", "pct_contam", "pct_contam_noisy", "pct_other")), 
                       aes(x = sample)) +
  geom_col(aes(y = value, fill = statistic), position = position_dodge()) +
  facet_wrap(~method) +
  scale_fill_manual(values = bar_colors[c(3, 4, 5, 2, 1)])
  #scale_fill_brewer(palette = "Set1")
summary_pct_bars

```


##Conduct some accessory analyses

Investigate how many of the filtered input reads are represented in the processed sequence tables. Is there much of a difference in how many reads are "kept" at different dilutions, or by different methods?
```{r reads kept}

# Get the number of raw reads and filtered reads for each sample
prefixes <- unique(sapply(str_subset(list.files(file.path(data_path, "raw")), "s\\d+.*"), str_replace, "_R.*", ""))
raw_reads <- sapply(prefixes, function(f) length(readFastq(file.path(data_path, "raw"), pattern = paste0(f, "_R1"))))
filtered_reads <- sapply(prefixes, function(f) length(readFastq(file.path(data_path, "filtered"), pattern = f)))

kept_reads <- matrix(0, nrow = length(methods), ncol = length(sample_names))
row.names(kept_reads) <- methods
colnames(kept_reads) <- sample_names

kept_reads["uclust", ] <- colSums(uclust_table[, sample_names]) / filtered_reads
kept_reads["uparse", ] <- colSums(uparse_table[, sample_names]) / raw_reads  # need to modify this to subtract unmapped reads
kept_reads["unoise", ] <- colSums(unoise_table[, sample_names]) / raw_reads  # same as previous line
kept_reads["med", ] <- colSums(med_table[, sample_names]) / filtered_reads
kept_reads["deblur", ] <- colSums(deblur_table[, sample_names]) / filtered_reads
kept_reads["dada2", ] <- track_table[, "non_chim"] / track_table[, "filtered"]

kept_reads <- as.tibble(rownames_to_column(as.data.frame(kept_reads), var = "method"))
kept_reads_gg <- gather(kept_reads, "sample", "pct_kept", sample_names)

library(directlabels)

# plot kept reads across dilutions, color-coded by method
kept_lines <- ggplot(kept_reads_gg, aes(x = sample, y = pct_kept)) +
  geom_line(aes(group = method, color = method)) +
  geom_dl(aes(label = method), method = list(dl.combine("first.qp", "last.qp"))) +
  labs(title = "Fraction of input reads represented in the processed output",
          x = "sample dilution", y = "proportion of input reads") + 
  scale_x_discrete(labels = dilution_labels)
kept_lines

```


Examine the relationship between read count and dilution at the sequence level. Are they correlated, and is the correlation positive or negative?
```{r dilution correlation}

# define a function to compute the Spearman correlation between rows of a sequence table and a specified vector of values
seqCor <- function(seq_tab, samples, vals) {
  sapply(seq_along(seq_tab[[1]]), function(row) {
    cor(seq_tab %>% select(samples) %>% slice(row) %>% unlist(., use.names = FALSE), vals, method = "spearman")
  })
}

method_tables <- lapply(method_tables, function(mt, snames, dilutions) {
  mt$dilution_cor <- seqCor(mt, snames, dilutions)
  return(mt)
}, snames = sample_names, dilutions = dilution_values)

# What are the dilution correlations for the reference sequences?
method_tables$uclust %>% filter(reference) %>% select(sample_names, dilution_cor)

# How many "contaminant-like" sequences have very strong negative correlations?
method_tables$uclust %>% filter(dilution_cor <= -.9, contam_like) %>% select(sample_names, dilution_cor)

# How many sequences are "contaminant-like" and have less than three zero sequence counts?
method_tables$dada2 %>% filter(contam_like, rowSums(.[, sample_names] == 0) < 3) %>% select(sample_names, dilution_cor)

# Of these, how many have negative dilution correlations?
method_tables$dada2 %>% filter(contam_like, rowSums(.[, sample_names] == 0) < 3, dilution_cor < 0) %>% 
  select(sample_names, dilution_cor)

# How many unclassified ("other") sequences have less than three zero counts?
method_tables$dada2 %>% filter(other, rowSums(.[, sample_names] == 0) < 4) %>% select(sample_names, dilution_cor)

# Of these, how many have negative dilution correlations?
method_tables$uparse %>% filter(other, rowSums(.[, sample_names] == 0) < 4, dilution_cor < 0) %>% 
  select(sample_names, dilution_cor)

```


Plot ratio of dada2 ASV_3 to ASV_8.
```{r}

# ratio <-  dada2_table %>% filter(id %in% c("ASV_3", "ASV_8")) %>% select(sample_names) 
# ratio <- ratio[1,] / ratio[2,]
# ratio <- gather(ratio, "sample", "ratio")
# 
# ggplot(data = dada2_gg %>% filter(id %in% c("ASV_3", "ASV_8")), aes(x = sample, y = count)) +
#   geom_line(aes(group = id, color = id)) +
#   geom_point(aes(color = id))
# 
# ggplot(ratio, aes(x = sample, y = ratio)) +
#   geom_line() +
#   geom_point()

```


Here, I'm going to perform a very simple analysis with the `phyloseq` package. The idea is to mimic a "typical" pre-processing analysis that a microbiome researcher might do with a dataset of biological sample(s). Namely, I'm going to investigate the effect of two common filtering/data reduction techniques applied to the already-clustered sequence/OTU tables:
1. Filtering candidate sequences/OTUs using a relative abundance threshold (e.g. 0.1% of total sample read count)
2. Combining similar sequences/OTUs using a taxonomy table by agglomerating to the genus level
First, I'll create `phyloseq` object to facilitate the analysis.
```{r create phyloseq}

library("phyloseq")

# extract sequence matrices of read counts only from the method sequence tibbles
seq_mats <- lapply(method_tables, function(mt){
  seq_mat <- as.matrix(mt[, sample_names])
  rownames(seq_mat) <- mt$id
  return(seq_mat)
})

# load taxonomy tables
tax_mats <- lapply(list.files(result_path), function(f){
  tax_table <- read.table(file.path(result_path, f, paste0(f, "_taxa.txt")), header = TRUE, sep = "\t")
  tax_mat <- as.matrix(tax_table)
  return(tax_mat)
})
names(tax_mats) <- list.files(result_path)
tax_mats <- tax_mats[methods]

# extract sequences from taxonomy tables and convert to DNAStringSet
seqs_list <- lapply(tax_mats, function(t) DNAStringSet(t[, 1]))

# remove sequences from taxonomy tables
tax_mats <- lapply(tax_mats, function(t) t[, -1])

# construct phyloseq OTU and taxonomy tables
otu_tabs <- lapply(seq_mats, otu_table, taxa_are_rows = TRUE)
tax_tabs <- lapply(tax_mats, tax_table)

# construct phyloseq objects
physeqs <- mapply(phyloseq, otu_tabs, tax_tabs, seqs_list, SIMPLIFY = FALSE)

# remove intermediate objects
rm(seq_mats, tax_mats, seqs_list, otu_tabs, tax_tabs)

```


Now I'll implement the filtering described above.
```{r phyloseq filter}

# convert sequence tables to relative abundances
read_counts <- lapply(physeqs, sample_sums)
physeqs.rel <- lapply(physeqs, transform_sample_counts, function(x) x / sum(x))

# remove observations that are below 0.1% relative abundance
physeqs.ab0.1 <- lapply(physeqs.rel, function(ps) {
  transform_sample_counts(ps, function(x) ifelse(x >= 1e-3, x, 0))
})
physeqs.ab0.1 <- lapply(physeqs.ab0.1, function(ps) {
  prune_taxa(taxa_sums(ps) > 0, ps)
})
invisible(mapply(function(ps, psa, id) cat("Total number of mock community sequences before filtering", toupper(id), "table:", ntaxa(ps), "\n",
                                           "Total number after filtering out sequences below 0.1% relative abundance:", ntaxa(psa), "\n\n"),
                 physeqs, physeqs.ab0.1, names(physeqs)))

# alternatively, agglomerate each OTU table to the genus level
physeqs.genus <- lapply(physeqs, tax_glom, taxrank = "Genus", NArm = FALSE)

# now apply both filters in sequence
physeqs.ab0.1.genus <- lapply(physeqs.ab0.1, tax_glom, taxrank = "Genus", NArm = FALSE)

```


Finally, convert the `phyloseq` OTU tables back to tibbles, and annotate them as was done above.
```{r annotate filtered tables}

# extract OTU tables from phyloseq objects
method_tables.filt <- mapply(function(ps, rc) {
  table <- otu_table(ps) 
  table <- sweep(table, MARGIN = 2, STATS = rc, `*`)
  table <- table %>% as.data.frame() %>% rownames_to_column(var = "id") %>% as.tibble()
  table$sequence <- refseq(ps) %>% as.character()
  return(table)
  },
  physeqs.ab0.1.genus, read_counts, SIMPLIFY = FALSE)

# annotate the filtered OTU tables
method_tables.filt <- mapply(function(mf, mt) {
  midx <- match(mf$sequence, mt$sequence)
  vars <- c("id", "dist_to_ref", "hit", "noisy", "ref_like", "perfect", "one_off", "contaminant", "other", "consensus", "dilution_cor")
  ann_tab <- mt[midx, vars]
  ann_tab <- full_join(mf, ann_tab, by = "id")
  return(ann_tab)
}, method_tables.filt, method_tables, SIMPLIFY = FALSE)

```

